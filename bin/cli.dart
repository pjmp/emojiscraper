import 'dart:io' show exit, File;

import 'package:args/args.dart' show ArgParser, ArgResults;
import 'package:emojiscraper/emojiscraper.dart' as scraper;
import 'package:interact/interact.dart' show Select, Spinner, SpinnerState;

// generated by `dart run build_runner`
import './app_info.dart' as app_info;

const _options = [
  {'name': 'help', 'help': 'Print this help message.', 'flag': true},
  {
    'name': 'interactive',
    'help': '''Interactively choose version from the list of available versions.
Note: if `--edition` is passed, this flag will be ignored.''',
    'flag': true
  },
  {'name': 'version', 'help': 'Print version information.', 'flag': true},
  {'name': 'list', 'help': 'List available emoji versions.', 'flag': true},
  {
    'name': 'edition',
    'help': '''Choose version of emoji, i.e 14.0, 13.1 etc.
Note: if version is not valid, it will exit with code `response.statusCode`.
      ''',
    'option': true
  },
  {
    'name': 'format',
    'help': 'Choose the format to dump to stdout or save to path.',
    'option': true,
    // 'defaultsTo': 'json',
    'allowed': {
      'raw': 'Data is not processed and left as it was downloaded.',
      'json': 'Data is parsed as JSON.',
    }
  },
  {
    'name': 'writeTo',
    'help': 'Write to path or stdout.',
    'option': true,
    // 'defaultsTo': 'stdout',
    'allowed': {
      'path': 'Write to path.',
      'stdout': 'Write to stdout.',
    }
  }
];

ArgParser _generate(ArgParser parser) {
  for (final option in _options) {
    final name = option['name'].toString();
    final abbr = name[0];
    final help = option['help'].toString();

    if (option['flag'] != null) {
      parser.addFlag(name, abbr: abbr, help: help, negatable: false);
    } else if (option['option'] != null) {
      final allowed = option['allowed'] != null
          ? (option['allowed'] as Map<String, String>)
          : null;

      parser.addOption(
        name,
        abbr: abbr,
        help: help,
        allowed: allowed?.keys.toList(),
        allowedHelp: allowed,
        defaultsTo: option['defaultsTo']?.toString(),
        valueHelp: name.toUpperCase(),
        // anything else to add?
      );
    }
  }

  return parser;
}

_validFlagsOrOptionsPassed(ArgResults cli) {
  return _options.any((option) => cli.wasParsed(option['name'].toString()));
}

String _usage() {
  final usage = '''USAGE:
  ${app_info.packageName} --format=raw --writeTo=path
  ${app_info.packageName} -fraw -wpath''';

  return usage;
}

Never _help(String appUsage) {
  final help = '''
${app_info.packageName} ${app_info.packageVersion}
${app_info.packageDescription}

${_usage()}

OPTIONS:
$appUsage''';

  print(help);

  exit(0);
}

Never _printNoArgsHelp() {
  print('''
error: --format=<FORMAT> --writeTo=<WRITETO> is required

${_usage()}

For more information try --help''');
  exit(1);
}

Never _version() {
  print(
      '${app_info.packageName} ${app_info.packageVersion} (${app_info.packageGitHash})');
  exit(0);
}

/// catch all for any errors
Never _printAllErrors(Object error) {
  print('''
${error.toString().replaceAll(RegExp(r'^(.*?Exception):'), 'error:')}

${_usage()}''');

  exit(1);
}

Never _invalidState() {
  print('Invalid option.\nRun `--help` to see all available options.');
  exit(1);
}

Future<Never> _printAvailableVersions() async {
  final spin = _spinner(message: 'Fetching available versions');

  final versions = await scraper.fetchAvailableVersions();

  spin.done();

  print('Available versions are:\n  ${versions.join('\n  ')}');
  exit(0);
}

SpinnerState _spinner({String message = ''}) {
  return Spinner(
    icon: '',
    rightPrompt: (done) => done ? '' : message,
  ).interact();
}

run({required List<String> args}) async {
  try {
    final app = _generate(ArgParser());

    final cli = app.parse(args);

    if (_validFlagsOrOptionsPassed(cli)) {
      // show help
      if (cli['help']) {
        _help(app.usage);
      }

      // show version
      if (cli['version']) {
        _version();
      }

      // list versions
      if (cli['list']) {
        await _printAvailableVersions();
      }

      var edition = cli['edition'];

      final format = cli['format'],
          writeTo = cli['writeTo'],
          interactive = cli['interactive'];

      // if `--edition` is not passed
      if (edition == null) {
        final spinner = _spinner(message: 'Fetching available versions');

        // fetch available versions
        final versions = await scraper.fetchAvailableVersions();

        spinner.done();

        // if `--interactive` is passed
        if (interactive != null && interactive == true) {
          // prompt user to select from available versions
          final selection = Select(
            prompt: 'Select version of emoji',
            options: versions,
          ).interact();

          edition = versions[selection];
        } else {
          // just select latest available version if `--interactive` is not passed
          edition = versions.first;
        }
      }

      final spinner = _spinner(message: 'Downloading');
      final data = await scraper.fetchEmojiData(edition);
      spinner.done();

      // dump to stdout
      if (writeTo == 'stdout') {
        if (format == 'raw') {
          print(data);
        } else if (format == 'json') {
          final json = scraper.parseTextToJson(data);
          print(json);
        } else {
          // this case should not execute..
          _invalidState();
        }
      } else if (writeTo == 'path') {
        if (format == 'raw') {
          final file = await File('$edition-emoji-sequences.txt').create();
          await file.writeAsString(data);
        } else if (format == 'json') {
          final json = scraper.parseTextToJson(data);
          final file = await File('$edition-emoji-sequences.json').create();
          await file.writeAsString(json);
        } else {
          // this case should not execute..
          _invalidState();
        }
      } else {
        _printNoArgsHelp();
      }
    } else {
      _printNoArgsHelp();
    }
  } catch (e) {
    _printAllErrors(e);
  }
}
